---
title: JVM 笔记（《深入理解 Java 虚拟机》）
description: jvm note
image: https://picsum.photos/536/354?random&date=2020-11-02
date: 2020-11-02
vssue-title: jvm note
tags:
  - knowledge
categories:
  - android
---

### 概述
记录了解 jvm 的过程

### mac 配置并编译 open jdk
#### 步骤
1、[拉取 open jdk 项目代码](https://github.com/openjdk/jdk)<br/>
2、安装编译环境
```
brew install freetype
brew install ccache
brew install autoconf

/**
 * 由于编译 open jdk 需要有 root jdk 的要求（文档地址: https://github.com/openjdk/jdk/blob/master/doc/building.md）
 * 因此还需要安装 root jdk，依然通过 brew 完成
 */
brew install cask
brew cask install adoptopenjdk
```
3、验证环境是否安装成功，在 jdk 目录下执行 bash configure，如果出现 configuration summary 的显示则表示编译环境 ok
```
bash configure --with-target-bits=64 --enable-ccache --with-jvm-variants=server,client --disable-warnings-as-errors --with-debug-level=fastdebug 2>&1 | tee configure_mac_x64.log
```
4、执行 make images 进行编译<br/>
5、编译完成后到 jdk 的 build 目录下验证编译后的 jdk 版本，路径 `./build/*/jdk/bin/`，使用该目录下的 java 命令查看 version，一般是 root jdk version +1
#### 问题
都是在执行 bash configure 这个命令提示的问题，只需要逐条解决即可<br/>
1、Runnable configure script is not present -> 执行 brew install autoconf<br/>
2、configure: error: No xcodebuild tool and no system framework headers found -> 执行 sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer<br/>
3、Could not find a valid Boot JDK -> 执行 brew cask install adoptopenjdk<br/>
4、command: cask not found -> 执行 brew install cask<br/>
5、此外如果在执行上述步骤过程中有遇到其他问题，应该可以根据提示解决，因此需要关注每次执行的结果~<br/>
#### 结果
经过上述配置，可以成功编译 jdk

### Java 内存管理
- **基本数据区域**<br/>
**方法区（Method Area）**: 所有线程共享的内存区域，用于存储已经被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据（别名: 非堆用于区分堆），这个区域回收目标主要是常量池的回收和对类型的卸载，如果方法区无法满足新的内存分配时，将会抛出内存溢出（OOM）。方法区还包含了**运行时常量池（Runtime Constant Pool）**-> 用于存放类在编译期生成的各种字面量与符号引用，在类加载后存放到这个区域（在运行期间也可以将新的常量加入到常量池中 String#intern()），当常量池无法再申请到内存是会抛出内存溢出（OOM）<br/>
**堆（Heap）**: 所有线程共享的内存区域，在虚拟机启动时创建，基本上用于存放对象实例，也是垃圾收集器所要管理的区域，分代管理只是为了更好地分配/回收内存，目前的虚拟机都是设计为可扩展的堆内存大小，如果堆中没有内存进行分配并且无法再扩展时，就会抛出内存溢出（OOM）<br/>
**虚拟机栈（VM Stack）**: 线程私有，执行的是字节码，描述的是 Java 方法执行的线程内存模型，每个方法被执行时，会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息，一个方法被调用完毕就对应一个栈帧在虚拟机中从入栈到出栈的过程。（是常说的栈内存或是指其中的局部变量表，会出现内存异常问题）<br/>
**本地方法栈（Native Stack）**: 与虚拟机栈的作用类似，但执行的是 Native 方法，可供虚拟机自由显示，同那样会出现内存异常问题。<br/>
**程序计数器（Program Counter Register）**: 可以看作是当前线程所执行的字节码的行号指示器，处理分支、循环、跳转、异常、线程恢复等基础功能。为了每个线程在切换后能正常恢复，每个线程都需要有一个独立的程序计数器，各个线程之间计数器互不影响。<br/>
- **其他数据区域**<br/>
**直接内存（Direct Memory）**: 并不是虚拟机运行时数据区的一部分也不是 Java 虚拟机中定义的内存区域，但这部分内存也被频繁地使用且也可能会导致OOM。JDK 1.4 中新引入了 NIO（New Input/Output）类，是一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作，在部分场景中提高了性能，这部分内存虽然不会收到堆内存大小限制，但会受物理机器总内存的限制。（在内存配置的过程中需要保留这部分内存，避免各个内存区域的总和大于物理内存，导致在动态扩展时出现 OOM）<br/>
- **常见的内存区域异常**<br/>
**StackOverflowError**: 如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出此异常<br/>
**OutOfMemoryError**: 如果 Java 虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存时，将会抛出此异常

### jvm 垃圾回收与内存分配策略
- **垃圾回收概述**<br/>
**确定区域**: Java 内存运行时区域中程序计数器、虚拟机栈、本地方法栈这三个区域的创建与回收是跟随线程进行的（栈中的栈帧随着方法的进入和退出执行入栈和出栈的操作，每一个栈帧所分配的内存都是确定的，因此这几个区域的内存分配与回收都比较确定，不必过多考虑回收的问题）<br/>
**非确定区域**: Java 堆和方法区就有这显著的不确定性（如一个接口有多个实现类，一个方法所执行的不同条件分支所需要的内存都不一样，只有在运行期间，才会知道创建了哪些对象，因此这部分内存的分配和回收是动态的）垃圾收集器所管理的正是这部分内存
- **判断对象是否存活**<br/>
**引用计数法**: 思路是在对象中添加引用计数器，每当有引用它时计数器值加一，引用失效则减一，计数器为零的对象表示不再被使用（但主流的 Java 虚拟机没有选用这种算法管理内存，因为需要配合大量额外处理才能保证正确，如对象间的循环引用，引用计数则无法回收）<br/>
**可达性分析算法**: 主流的内存管理方式，思路通过一系列被称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径成为“引用链”，如果某个对象到 GC Roots 间没有任何引用链相连（从 GC Roots 到这个对象不可达），就证明对象不能再被使用<br/>
- **GC Roots 对象**<br/>
1、在虚拟机栈（栈帧中的本地变量表）中引用的对象（如: 各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量..）<br/>
2、在方法区中类静态属性引用的对象（如: Java 类的引用类型静态变量）<br/>
3、在方法区中常量引用的对象（如: 字符串常量池（String Table）里的引用<br/>
4、在本地方法栈中 JNI（Native 方法）引用的对象<br/>
5、Java 虚拟机内部的引用（如: 基本数据类型对应的 Class 对象，一些常驻的异常对象（NullPointException、OutOfMemoryError ）等，还有系统类加载器<br/>
6、所有被同步锁（synchronized 关键字）持有的对象<br/>
7、反映 Java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等<br/>
此外，还可以有其他对象临时性加入（在不同的内存区域）共同构成完整 GC Roots 集合<br/>
- **对象死亡过程**<br/>
一个对象死亡，至少要经历两次标记过程: 如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记，随后进行一次筛选，条件是此对象是否有必要执行 finalize()，若对象没有覆盖 finalize() 或 finalize() 已被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”，如果判定为有必要执行 finalize() 那么该对象将会被放置在一个名为 F-Queue 的队列中，并在稍后由一条由虚拟机自动建立的、低调度优先级的 Finalizer 线程去执行它们的 finalize()，虚拟机会触发 finalize() 开始运行，但不承诺要等待它运行结束，是因为如果某个对象的 finalize() 执行缓慢或者发生死循环，将会可能导致 F-Queue 队列中的其他对象永久处于等待，甚至导致整个内存回收子系统崩溃。<br/>
- **回收方法区**<br/>
方法区的垃圾手机主要回收废弃的常量和不再使用的类型<br/>
对于常量是否可以被回收只需要判断是否有引用可达该常量<br/>
而类型是否可以被回收则需要同步满足一下三个条件:<br/>
1、该类所有的实例都已经被回收，即 Java 堆中不存在该类及其任何派生子类的实例<br/>
2、加载该类的类加载器已经被回收，（比较难达成）<br/>
3、该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过发射访问该类的方法<br/>
- **分代收集（主流的垃圾收集方法）**<br/>
设计原则: 收集器应该将 Java 堆划分出不同的区域，然后将回收对象依据其年龄（即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储（能同时兼顾垃圾收集的时间开销和内存的空间有效利用）<br/>
在 Java 堆划分出不同的区域后，垃圾收集器才可以每次只回收其中某一个或某些部分的区域，因而发展出“标记-复制算法”“标记-清除算法”“标记-整理算法”<br/>
一般的设计中会将 Java 堆划分为新生代（每次垃圾收集会出现大批对象死去）和老年代（每次回收后存活少量对象在这存放）<br/>
**标记-清除算法**: 是最基础的收集算法，分为标记和清除两个阶段，先标记出所有需要回收的对象，标记完成后，统一回收所有被标记的对象。缺点: 1、执行效率不稳定（若 Java 堆中包含大量对象，且其中大部分是要被回收的，此时就需要进行大量标记和清除的动作，导致执行这两过程的效率降低）2、内存空间的碎片化问题（清除后会产生大量不连续的内存碎片，碎片太多会导致程序在之后的运行过程中要分配较大对象时，无法找到足够的连续内存而需要继续出发 GC）<br/>
**标记-复制算法（复制算法）**: 为了解决标记-清除算法面对大量可回收对象时执行效率低的问题。它将可用内存按容量划分为大小相等的两块，每次只用其中一块，当这块内存用完了，就将还存活着的对象复制到另外一块去，然后把已使用过的内存空间一次清理掉。缺点: 当内存中多数对象都是存活时，这种方法也会产生较大的开销，另外还将可用内存缩小了一半。目前的优化是调整两块区域的大小（再额外区分出一个担保区间减少 50% 内存空间的浪费）<br/>
**标记-整理算法**: 为了解决标记-复制算法在对象存活率较高时复制操作增多导致效率下降的问题，在老年代中会使用标记-整理算法，标记过程跟标记-清除算法一样，但后续不是直接对可回收对象进行整理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。但在老年代中由于每次回收都有大量对象存活，移动存活对象并更新所有引用这些对象的地方也是一种很重的操作（这操作还必须全程暂停用户应用程序才能进行，这样的停顿被描述为“Stop The World”）<br/>
- **内存分配与回收策略**<br/>
1、对象优先在新生代 Eden 区中分配，当 Eden 区没有足够空间进行分配时，虚拟机将发起一次新生代 GC<br/>
2、大对象（需要大量连续内存空间的 Java 对象）直接进入老年代<br/>
3、长期存活的对象将进入老年代（当对象的年龄（GC 的次数）增加到一定程度（默认为 15），那么就会被虚拟机认为是长期存活的对象，就会进入老年代）<br/>
4、动态对象年龄判定（虚拟机会结合对象大小总和与 Survivor 空间（担保）大小进行判断）<br/>
5、空间分配担保（就是判断老年代能否需要进行 GC 来配合新的对象进入老年代）<br/>

### 虚拟机类加载机制
- **定义**: Java 虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型的过程（类型的加载、连接、初始化都是在程序运行期间完成的）这个特性虽然会让类在加载时增加一些性能开销，但却提供了极高的扩展性和灵活性，Java 可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的<br/>
- **加载过程**: 一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它整个生命周期将会经历加载(loadinng) -> 验证(verification) -> 准备(preparation) -> 解析(resolution) -> 初始化(initialization) -> 使用(using) -> 卸载(unloading)（验证 -> 准备 -> 解析这三部分统称为连接(linking)），**解析**阶段的加载过程会根据实际情况，可以在初始化阶段之后再开始（为了支持 Java 语言的运行时绑定特性）<br/>
- **加载**: 需要完成1、通过一个类的全名来获取定义此类的二进制字节流; 2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构; 3、在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口<br/>
非数组类型的加载阶段，既可以使用 Java 虚拟机里内置的引导类加载器来完成，也可以由用户自定义的类加载器来完成<br/>
数组类型本身不通过类加载器创建，是由 Java 虚拟机直接在内存中动态构造出来，数组类的元素类型最终还是需要靠类加载器来完成加载<br/>
加载阶段结束后，Java 虚拟机外部的二进制字节流会按照虚拟机所设定的格式存储在方法区中，方法区中的数据存储格式全由虚拟机实现自行定义，类型数据存在方法区后，会在 Java 堆内存中实例化一个 java.lang.Class 类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口<br/>
加载阶段与连接阶段（如一部分字节码文件格式验证动作）的部分动作是交叉进行的，加载阶段还未完成，连接阶段就可能已经开始（这些夹在加载阶段中进行的动作，仍然属于连接阶段的一部分，这两阶段的开始时间仍然保持着固定的先后顺序）







































